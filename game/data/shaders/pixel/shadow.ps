
varying vec2 v_texCoord;

uniform sampler2D depthTexture;
uniform sampler2D normalTexture;
uniform mat4 screenToWorld;
uniform mat4 worldToShadowMap;
uniform sampler2D shadowMapTexture;
uniform vec3 lightPosition;
//float bias = 0.00001;

vec3 restoreWorldPosition()
{
    float x = v_texCoord.x * 2 - 1;
    float y = v_texCoord.y * 2 - 1;
    float z = texture2D(depthTexture, v_texCoord).x * 2 - 1;
    vec4 projectedPos = vec4(x, y, z, 1);
    vec4 pos = screenToWorld * projectedPos;
    return pos.rgb / pos.w;
}

float sampleShadow(vec2 uv, float depth, float bias)
{
    float lightDepth = texture2D(shadowMapTexture, uv).x;
    return depth - bias > lightDepth ? 0 : 1;
}

float getShadow(vec4 sMapPos, float bias)
{
    float shadow = 0;
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            vec2 offset = vec2(float(x) / 1024, float(y) / 1024);
            shadow += sampleShadow(sMapPos.xy + offset, sMapPos.z, bias);
        }
    }
    return shadow / 9;
}

void main()
{	
    vec3 position = restoreWorldPosition();
    
    vec3 l = normalize(lightPosition - position);
    vec3 n = texture2D(normalTexture, v_texCoord).rgb * 2 - 1;
    float p = dot(l, n);   
    
    float shadow = 0;
    
    if (p > 0)
    {
        float k = (1 - p);
        //position = position + n * 0.001 + 0.1 * k * k;
        position = position + n * mix(0.01, 0.1, k * k * k);
    
        vec4 sMapPos = worldToShadowMap * vec4(position, 1);
        sMapPos = (sMapPos / sMapPos.w) / 2 + 0.5; // 0..1
        shadow = getShadow(sMapPos, 0);   
    }
    
    shadow = mix(0.5, 1, shadow);
    
    float diffuse = p / 2 + 0.5;
    float c = min(diffuse, shadow + (diffuse - shadow) * 0.3);
    c = shadow;
    
    gl_FragColor = vec4(c, c, c, 1);
}


    